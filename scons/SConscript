Import('env')

import os

TARGET = '#' + env['APP_TARGET']

SOURCES = map(lambda s: os.path.isabs(s) and s or ('#../src/' + s), env['APP_SOURCES'])

platform = env['PLATFORM']

INCLUDES = ['#../include']

INCLUDES += ['../include',
		'../boost',
		'../include/rapidxml',
		'../include/cinder/app',
		'../src/AntTweakBar',
		'../src/libtess2']

if 'DEBUG' in env:
	DEBUG = env['DEBUG']
else:
	DEBUG = 0

if DEBUG:
	LIBS = ['cinder_d']
else:
	LIBS = ['cinder']

if platform == 'darwin':
	LIBS += ['libc++']
	LIBPATH = ['../lib/macosx/']
elif platform == 'win32':
	env['ENV']['PATH'] = os.environ['PATH']
	env['ENV']['INCLUDE'] = os.environ['INCLUDE']
	env['ENV']['LIB'] = os.environ['LIB']
	# linker is specified with full path because of conflict with cygwin's link command
	env['LINK'] = '"' + os.environ['VSINSTALLDIR'] + '\VC\\bin\link.exe"'
	LIBS += Split(
		'advapi32.lib comdlg32.lib gdi32.lib kernel32.lib odbc32.lib ' + \
		'odbccp32.lib ole32.lib oleaut32.lib shell32.lib ' + \
		'user32.lib uuid.lib winspool.lib ')
	LIBPATH = ['../lib/msw/x86']
else:
	LIBPATH = []

LIBPATH += ['.']

if platform == 'darwin':
	LIBS += [File(LIBPATH[0] + s) for s in Split('libboost_date_time.a libboost_system.a ' + \
			'libboost_filesystem.a libz.a')]
elif platform == 'posix':
	for lib in ['x11', 'gl', 'libcurl', 'zlib']:
		env.ParseConfig('pkg-config --cflags --libs %s' % (lib))
	# FIXME: no boost pkg-config
	LIBS += ['boost_date_time-mt', 'boost_system-mt', 'boost_thread-mt',
			'boost_filesystem-mt']
	# librt for glibc timer
	LIBS += ['rt']

if platform != 'win32':
	CFLAGS = ' -fmessage-length=0 -Wno-trigraphs ' + \
			' -Wno-missing-field-initializers -Wreturn-type ' + \
			' -Wno-missing-prototypes -Wformat -Wno-missing-braces -Wparentheses ' + \
			' -Wswitch -Wno-unused-function -Wno-unused-label ' + \
			' -Wno-unused-parameter -Wunused-variable -Wunused-value ' + \
			' -Wno-empty-body -Wno-uninitialized -Wno-unknown-pragmas -Wno-shadow ' + \
			' -Wno-four-char-constants -Wno-conversion -Wno-shorten-64-to-32 ' + \
			' -Wpointer-sign -Wno-newline-eof -fasm-blocks -ffast-math ' + \
			' -Wdeprecated-declarations -Wno-sign-conversion ' + \
			' -fstrict-aliasing '
else:
	INCLUDES += ['../include/msw/png', '../include/msw/zlib',
			'../include/msw', '../blocks/QuickTime/include/msw',
			'../src/DxShaders']
	CFLAGS = '/GS /GL /analyze- /W3 /Zc:wchar_t /Zi /Gm- /Ox /O2 /fp:precise ' + \
			'/D "WIN32" /D "NDEBUG" /D "_WINDOWS" '+ \
			'/D "_UNICODE" /D "UNICODE" ' + \
			'/errorReport:prompt /WX- /Zc:forScope /FS /Gd /Oy- /Oi ' + \
			'/MT /Ot /EHsc /nologo /arch:SSE2 '

	CCFLAGS = CFLAGS
	CPPPATH = []

if platform != 'win32':
	LINKFLAGS = ' -dead_strip '
else:
	LINKFLAGS = '/LTCG /NOLOGO /DYNAMICBASE:NO /SAFESEH ' + \
			'/MACHINE:X86 /OPT:REF ' + \
			'/INCREMENTAL:NO /SUBSYSTEM:WINDOWS ' + \
			'/ERRORREPORT:PROMPT /TLBID:1'

if platform != 'win32':
	if DEBUG:
		if platform == 'darwin':
			CFLAGS += '-g -O0 '
		else:
			CFLAGS += '-ggdb2 -O0 '
	else:
		CFLAGS += '-g0 -O3 '

if platform == 'darwin':
	env['CC'] = 'clang'
	env['CXX'] = 'clang++'

	CFLAGS += ' -arch i386 -mmacosx-version-min=10.7 ' + \
		' -fpascal-strings '
	LINKFLAGS += ' -arch i386 -all_load -mmacosx-version-min=10.7 '

	if 'ICON' not in env:
		ICON = '../samples/data/CinderApp.icns'
	else:
		ICON = '#../resources/' + env['ICON']

	AddOption('--bundle', action='store_true', help='Build OSX bundle')
	if GetOption('bundle'):
		LINKFLAGS += '-bundle '

elif platform == 'posix':
	CFLAGS += '-pthread '

if platform != 'win32':
	CCFLAGS = CFLAGS + ' -x c++ -fvisibility-inlines-hidden -std=c++11 ' + \
			' -stdlib=libc++ -Wno-non-virtual-dtor -Wno-overloaded-virtual ' + \
			' -Wno-exit-time-destructors -Wno-c++11-extensions -Winvalid-offsetof '

	CPPPATH = ['/usr/include']

CPPPATH += INCLUDES

env.Append(CCFLAGS = Split(CCFLAGS))
env.Append(CPPPATH = CPPPATH)
env.Append(LIBPATH = LIBPATH)
env.Append(LIBS = LIBS)
env.Replace(LINKFLAGS = Split(LINKFLAGS))

if platform == 'darwin':
	env.Append(FRAMEWORKS = Split('Accelerate AppKit ApplicationServices AudioUnit ' + \
		'AudioToolbox AVFoundation Cocoa CoreAudio CoreData CoreGraphics ' + \
		'CoreMedia CoreVideo Foundation OpenGl QuickTime QTKit '))

	# change compile flags for ObjC files
	CCFLAGS_OBJC = CFLAGS + ' -x objective-c++ -fvisibility-inlines-hidden ' + \
		'-std=c++11 -stdlib=libc++ -Wno-implicit-atomic-properties ' + \
		'-Wno-receiver-is-weak -Wno-non-virtual-dtor -Wno-overloaded-virtual ' + \
		'-Wno-exit-time-destructors -Wno-selector -Wno-strict-selector-match ' + \
		'-Wno-undeclared-selector -Wno-deprecated-implementations -Wno-arc-abi ' + \
		'-Wno-c++11-extensions -Wprotocol -Winvalid-offsetof ' + \
		'"-DIBOutlet=__attribute__((iboutlet))" ' + \
		'"-DIBOutletCollection(ClassName)=__attribute__((iboutletcollection(ClassName)))" ' + \
		'"-DIBAction=void)__attribute__((ibaction)" '
	if 'COMPILE_AS_MM' not in env:
		env['COMPILE_AS_MM'] = []
	from os.path import basename
	for i in range(len(SOURCES)):
		if SOURCES[i].endswith('.mm') or SOURCES[i].endswith('.m') or \
			(basename(SOURCES[i]) in env['COMPILE_AS_MM']):
				SOURCES[i] = env.Object(SOURCES[i], CCFLAGS = CCFLAGS_OBJC)

if 'RESOURCES' not in env:
	RESOURCES = []
else:
	# if a resource contains a regular expression call Glob
	resources = []
	abs_resources = Dir('#../resources/').abspath
	for res in env['RESOURCES']:
		if 1 in [c in res for c in '*?[]']:
			glob_resources = Glob('#../resources/' + res, strings = True)
			# convert to relative path
			resources += [os.path.relpath(f, abs_resources) for f in glob_resources]
		else:
			resources.append(res)
	RESOURCES = map(lambda s: os.path.isabs(s) and s or [('#../resources/' + s), s], resources)

if 'ASSETS' not in env:
	ASSETS = []
else:
	# if an asset contains a regular expression call Glob
	assets = []
	abs_assets = Dir('#../assets/').abspath
	for asset in env['ASSETS']:
		if 1 in [c in asset for c in '*?[]']:
			glob_assets = Glob('#../assets/' + asset, strings = True)
			# convert to relative path
			assets += [os.path.relpath(f, abs_assets) for f in glob_assets]
		else:
			assets.append(asset)
	ASSETS = map(lambda s: os.path.isabs(s) and s or [('#../assets/' + s), 'assets/' + s], assets)

if platform == 'win32' and RESOURCES:
	if 'RESOURCES_RC' not in env:
		RESOURCES_RC = '#../vc2012/Resources.rc'
	if not File(RESOURCES_RC).exists():
		RESOURCES_RC='#Resources.rc'
		from wintools import *
		TOOL_CINDER_RES_RC(env)
		env.CinderResRc(target = RESOURCES_RC, source = '#../include/Resources.h')
	SOURCES += [env.RES(RESOURCES_RC)]
if platform == 'win32' and ASSETS:
	for (src, dst) in ASSETS:
		src = Entry(src).abspath
		env.Command('#' + dst, src, Copy(dst, src))
		env.Clean(TARGET, '#assets')

# build the application
env.Program(source = SOURCES, target = TARGET)

# build the osx app
if platform == 'darwin':
	import sys, os
	from osxbundle import *
	TOOL_BUNDLE(env)

	if 'PLIST' not in env:
		PLIST = '#../xcode/Info.plist',
	else:
		PLIST = '#' + env['PLIST']
		
	if GetOption('bundle'):
		bundle_name = TARGET + '.bundle'
		typecode = 'BNDL'
	else:
		bundle_name = TARGET + '.app'
		typecode = 'APPL'

	env.Alias('app', env.MakeBundle(bundle_name,
		TARGET,
		'key',
		PLIST,
		resources = RESOURCES + ASSETS,
		typecode = typecode,
		icon_file = ICON,
		subst_dict = {'\${EXECUTABLE_NAME}': TARGET[1:],
						'\${PRODUCT_NAME}': TARGET[1:],
						'\${ICON_FILE}': basename(ICON)}))

	env.Clean(TARGET, bundle_name)
elif platform == 'win32':
	env.Clean(TARGET, '#vc120.pdb')


# run
if platform == 'darwin':
	env.AlwaysBuild(env.Alias('run', [TARGET + '.app'], 'open %s' % env.Dir(TARGET + '.app').abspath))

